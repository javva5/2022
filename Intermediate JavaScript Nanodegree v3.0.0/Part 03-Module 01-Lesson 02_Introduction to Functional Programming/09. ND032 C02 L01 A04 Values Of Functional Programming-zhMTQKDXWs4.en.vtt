WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.120
In this section, we're going to talk about some of the features of

00:00:03.120 --> 00:00:06.810
functional programming that have developers so interested in using it.

00:00:06.810 --> 00:00:10.260
Probably, the biggest benefit of functional programming

00:00:10.260 --> 00:00:13.830
that have developers wanting to use it is confidence.

00:00:13.830 --> 00:00:17.790
Our confidence mainly comes from the no side effects rule.

00:00:17.790 --> 00:00:20.580
For instance, imperative code is very straight

00:00:20.580 --> 00:00:23.835
forward to reason about with simple or small programs.

00:00:23.835 --> 00:00:26.645
But as processes grow in size and complexity,

00:00:26.645 --> 00:00:28.495
it can create spaghetti code.

00:00:28.495 --> 00:00:33.155
The reality is that a clean codebase can be written in any language or paradigm.

00:00:33.155 --> 00:00:36.020
But some aspects of functional programming at least guard

00:00:36.020 --> 00:00:38.765
against certain bug introducing habits.

00:00:38.765 --> 00:00:42.230
One main rule that protects you from particularly hard to

00:00:42.230 --> 00:00:46.390
debug issues is the rule of no side effects in functions.

00:00:46.390 --> 00:00:53.335
Another benefit of using the functional paradigm is simplicity or avoiding global state.

00:00:53.335 --> 00:00:57.050
Keeping track of state is difficult in any programming paradigm.

00:00:57.050 --> 00:00:59.300
So It's no wonder that each of them has

00:00:59.300 --> 00:01:02.120
a slightly different way of reasoning about state,

00:01:02.120 --> 00:01:06.785
and lambda calculus does not actually have a global state at all,

00:01:06.785 --> 00:01:09.845
but our applications need state.

00:01:09.845 --> 00:01:13.150
In functional programming, we tend to use one read

00:01:13.150 --> 00:01:16.970
only state that the rest of the application can refer back to.

00:01:16.970 --> 00:01:19.505
This is seen as being preferable to letting

00:01:19.505 --> 00:01:22.715
everything update state as in the imperative style,

00:01:22.715 --> 00:01:28.115
or to holding state in pieces across many objects or the object oriented style.

00:01:28.115 --> 00:01:32.405
The final benefit of functional programming we'll take a look is clarity.

00:01:32.405 --> 00:01:35.350
Clarity through the use of immutable values.

00:01:35.350 --> 00:01:38.930
Applications grow more complex and interactive everyday,

00:01:38.930 --> 00:01:43.655
which means keeping track of changes in large production applications can be difficult.

00:01:43.655 --> 00:01:46.490
If a variable's value cannot change,

00:01:46.490 --> 00:01:49.805
that means its value is stable across your entire app,

00:01:49.805 --> 00:01:52.925
something that can't be taken for granted in other paradigms.

00:01:52.925 --> 00:01:55.210
This goes back to the confidence point.

00:01:55.210 --> 00:01:58.580
But functional programs can allow a high degree of clarity or

00:01:58.580 --> 00:02:02.360
visibility for developers about what's going on inside their programs.

00:02:02.360 --> 00:02:05.940
This means less mental strain for developers.

