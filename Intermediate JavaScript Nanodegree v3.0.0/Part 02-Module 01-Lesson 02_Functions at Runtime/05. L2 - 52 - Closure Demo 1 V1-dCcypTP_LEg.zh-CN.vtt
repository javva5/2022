WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:01.794
这里有几个函数和变量

00:00:01.794 --> 00:00:05.195
首先有一个叫做 number 的全局变量 它设为了数字 3

00:00:05.195 --> 00:00:09.539
还有一个更高阶的函数 叫做 number

00:00:09.539 --> 00:00:12.029
在 myFunction 中有一个局部变量

00:00:12.029 --> 00:00:14.894
叫做 otherNumber 设成了数字 1

00:00:14.894 --> 00:00:17.189
还有一个函数 叫做 logger

00:00:17.190 --> 00:00:20.780
loggers 的作用是将 otherNumber 输出到控制台中

00:00:20.780 --> 00:00:24.300
在最后 myFunction 返回 logger

00:00:24.300 --> 00:00:32.855
我们调用 myFunction 并将该结果存储到叫做 result 的变量中

00:00:32.854 --> 00:00:35.729
调用 myFunction 后返回的值

00:00:35.729 --> 00:00:39.182
将存储在变量 result 中

00:00:39.182 --> 00:00:42.670
如果调用 result

00:00:42.810 --> 00:00:47.737
可以看到它向控制台中输出了 1

00:00:47.737 --> 00:00:49.685
为何会这样？

00:00:49.685 --> 00:00:51.875
因为闭包的原因

00:00:51.875 --> 00:00:58.149
logger 捕获了在 myFunction 内局部声明的 otherNumber 变量

00:00:58.149 --> 00:01:01.489
换句话说 嵌套的 logger 函数

00:01:01.490 --> 00:01:05.585
依然能够访问父函数作用域内的 otherNumber 变量

00:01:05.584 --> 00:01:08.979
即使在父函数返回之后

00:01:08.980 --> 00:01:10.969
我们再仔细研究下该函数

00:01:10.969 --> 00:01:14.534
我将刷新控制台并执行刚刚执行的操作

00:01:14.534 --> 00:01:17.280
但是在这里添加调试程序

00:01:17.280 --> 00:01:22.346
现在如果再次调用 result

00:01:22.346 --> 00:01:27.390
我们暂停了执行代码并位于第七行

00:01:27.390 --> 00:01:30.980
查看屏幕右侧内容

00:01:30.980 --> 00:01:33.439
会在这里看到闭包

00:01:33.439 --> 00:01:36.045
打开它 很有趣

00:01:36.045 --> 00:01:38.489
这里有个 otherNumber 变量

00:01:38.489 --> 00:01:42.170
它是 logger 函数闭包的变量

00:01:42.170 --> 00:01:47.430
总结下 logger 等函数即使在父函数返回后

00:01:47.430 --> 00:01:52.000
也可以引用其父函数的作用域 即 myFunction

