WEBVTT
Kind: captions
Language: zh-CN

00:00:00.050 --> 00:00:03.149
这是一个 Animal 构造函数

00:00:03.149 --> 00:00:06.439
以及一个在 Animal 的原型上直接定义的 Walk 方法

00:00:06.440 --> 00:00:09.445
此外 还有一个 Cat 构造函数

00:00:09.445 --> 00:00:12.240
但是 你可能注意到的一点是

00:00:12.240 --> 00:00:15.765
我们在 Cat 构造函数中使用了 call 方法

00:00:15.765 --> 00:00:19.425
并且直接在 Animal 构造函数中调用它

00:00:19.425 --> 00:00:21.179
原因是 我们想要在 Cat 实例或 Cat 对象上

00:00:21.179 --> 00:00:25.564
调用超级构造函数

00:00:25.565 --> 00:00:29.920
否则 this.name 将是 undefined

00:00:29.920 --> 00:00:34.079
此外 当我们想要调用 Animal 构造函数时

00:00:34.079 --> 00:00:36.179
我们使用 call 而不是关键字 new

00:00:36.179 --> 00:00:38.829
因为我们不想构造一个全新的 animal 对象

00:00:38.829 --> 00:00:41.714
我们只关心 cat 实例或 cat 对象上的

00:00:41.715 --> 00:00:45.160
animal 初始化逻辑

00:00:45.159 --> 00:00:52.306
call 方法的作用是调用 Animal 并将 this 设为 cat 实例

00:00:52.307 --> 00:00:55.304
按下 Return 键

00:00:55.304 --> 00:01:03.712
现在有了这个继承自 Animal 的 Cat

00:01:03.712 --> 00:01:08.585
我们还需要更改构造函数

00:01:08.584 --> 00:01:14.079
否则 所有 cat 对象的构造函数将设为 animal

00:01:14.079 --> 00:01:18.209
但是它应该设为 cat 我们修改下

00:01:19.890 --> 00:01:25.575
清空控制台 留出更多的空间

00:01:25.575 --> 00:01:27.189
现在 我们向 cat 的原型添加一个方法

00:01:27.189 --> 00:01:32.879
使所有 cat 对象都能共享该方法 称之为 Meow

00:01:35.219 --> 00:01:38.780
现在使用关键字 new 调用 cat 构造函数

00:01:38.780 --> 00:01:44.555
并初始化新的 cat 对象 称之为 Bambi

00:01:44.555 --> 00:01:49.606
确保 bambi 具有我们想要的所有属性和方法

00:01:49.606 --> 00:01:59.174
有 Meow 还有继承自 animal 构造函数的 walk 方法

00:01:59.174 --> 00:02:02.334
当然 当我们调用 bambi.name 时

00:02:02.334 --> 00:02:06.399
获得了 Bambi 的名字

00:02:06.400 --> 00:02:10.480
总结下 为了在 JavaScript 中有效地管理继承

00:02:10.479 --> 00:02:12.715
一个很好的方式是避免完全更改原型

00:02:12.715 --> 00:02:17.740
为此 我们可以使用 object.create

