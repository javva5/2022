WEBVTT
Kind: captions
Language: ar

00:00:00.000 --> 00:00:02.475
لدينا هنا كائن iceCreamTotals،

00:00:02.475 --> 00:00:04.679
والذي يظهر العدد الإجمالي لغالونات الآيس كريم

00:00:04.679 --> 00:00:07.339
التي قد أكلها كل عضو من فريق موقع Udacity.

00:00:07.339 --> 00:00:12.269
فيرونيكا 600، جيسيكا 818، ديفيد أكثر من 9000.

00:00:12.269 --> 00:00:15.054
لا يبدو أن ريتشارد دقيقًا للغاية.

00:00:15.054 --> 00:00:17.532
لننطلق ونضيف زوجين أكثر
من الأصفار عليه.

00:00:17.532 --> 00:00:19.646
رائع.

00:00:19.646 --> 00:00:24.870
لنفترض الآن أنني أردت مصفوفة من المفاتيح فقط في كائن
iceCreamTotals هذا،

00:00:24.870 --> 00:00:27.105
مما يعني أنني أريد مصفوفة من فيرونيكا فقط،

00:00:27.105 --> 00:00:29.493
أندرو وجيسيكا وديفيد وريتشارد.

00:00:29.493 --> 00:00:34.170
ما يمكن أن نقوم به هو استدعاء Object.keys وتمريرها
عبر كائن iceCreamTotals.

00:00:34.170 --> 00:00:38.554
لنتابع ونفعل هذا.

00:00:38.554 --> 00:00:43.070
يمكنك رؤية كيفية قيمة إرجاع استدعاء Object.keys
وتمرير iceCreamTotal،

00:00:43.070 --> 00:00:46.380
والتي تعطينا مصفوفة من جميع المفاتيح في ذلك الكائن
الأصلي.

00:00:46.380 --> 00:00:50.355
الآن، ماذا إذا كنا نريد مصفوفة واحدة فقط من قيم هذا
الكائن؟

00:00:50.354 --> 00:00:52.484
حسنا فبالمثل، يمكننا فقط الضغط على

00:00:52.484 --> 00:00:57.479
Object.values لتمرير نفس الكائن. يمكننا الحصول على
تلك المصفوفة.

00:00:57.479 --> 00:01:02.319
لدينا هنا مصفوفة من القيم 600 فقط حتى نهاية المسار

00:01:02.320 --> 00:01:08.784
حتى 10 مليون لريتشارد. حسنًا.

00:01:08.784 --> 00:01:10.329
كان ذلك مجرد مسح،

00:01:10.329 --> 00:01:13.920
طريقة سريعة جدًا لتنفيذ هذه الأشياء للحصول على القيم
الأساسية.

00:01:13.920 --> 00:01:17.995
ما كان بإمكاننا القيام به أيضًا هو مجرد عمل تكرار
حلقي من أجل إنشاء مصفوفة.

00:01:17.995 --> 00:01:19.660
على غرار الإعدادات الأصلية،

00:01:19.659 --> 00:01:21.724
لدينا كائن iceCreamTotals،

00:01:21.724 --> 00:01:24.384
نفس المعلومات ولكن ما نفعله الآن

00:01:24.385 --> 00:01:27.530
هو إنشاء مصفوفة النتائج التي سيتم بنائها،

00:01:27.530 --> 00:01:32.368
ثم التكرار من خلال الكائن iceCreamTotals بواسطة
تكرار حلقي.

00:01:32.368 --> 00:01:37.626
والآن، إذا قمت بفحص مصفوفة النتيجة،

00:01:37.626 --> 00:01:40.064
فسترى أنها تعطينا نفس الناتج.

00:01:40.064 --> 00:01:42.718
دعني أنطلق وأضع هذا جنباً إلى جنب.

00:01:42.718 --> 00:01:46.189
لاحظ أن نتيجة المصفوفة التي قمنا بإنشائها بأنفسنا
تعطينا

00:01:46.189 --> 00:01:50.599
نفس ناتج استدعاء Object.keys الذي أنشأناه في
الأصل.

00:01:50.599 --> 00:01:55.364
يعطينا استخدام Object.keys نفس النتيجة كما لو كنا
ننفذ التكرار من خلاله بأنفسنا،

00:01:55.364 --> 00:01:58.119
لكنه أكثر قليلا في قابليته للقراءة وأيضًا أقل كثيرًا
في كتابة الأكواد.

