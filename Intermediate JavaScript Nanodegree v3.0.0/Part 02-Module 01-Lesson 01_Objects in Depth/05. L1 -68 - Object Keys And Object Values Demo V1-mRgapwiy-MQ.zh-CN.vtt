WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.475
这是 iceCreamTotals 对象

00:00:02.475 --> 00:00:04.679
表示优达学城网络团队每位成员

00:00:04.679 --> 00:00:07.339
吃掉的冰激凌总量（加仑）

00:00:07.339 --> 00:00:12.269
Veronica 吃了 600 加仑 Jessica 吃了 818 加仑 David 超过了 9,000 加仑

00:00:12.269 --> 00:00:15.054
Richard 的似乎不太准确

00:00:15.054 --> 00:00:17.532
在他的数据后面添加几个零

00:00:17.532 --> 00:00:19.646
很棒

00:00:19.646 --> 00:00:24.870
现在我想创建一个数组 其中仅包含这个 iceCreamTotals 对象中的键

00:00:24.870 --> 00:00:27.105
即数组中只包含 Veronica

00:00:27.105 --> 00:00:29.493
Andrew Jessica David 和 Richard

00:00:29.493 --> 00:00:34.170
我们可以调用 Object.keys 并传入 iceCreamTotals 对象

00:00:34.170 --> 00:00:38.554
我们来这么操作

00:00:38.554 --> 00:00:43.070
可以看到传入 iceCreamTotals 后

00:00:43.070 --> 00:00:46.380
为我们提供了由原始对象中的所有键组成的数组

00:00:46.380 --> 00:00:50.355
如果我们只想获得由该对象的值组成的数组呢？

00:00:50.354 --> 00:00:52.484
同样 我们可以调用 Object.values

00:00:52.484 --> 00:00:57.479
并传入相同的对象 就可以获得该数组

00:00:57.479 --> 00:01:02.319
我们获得了由值 600 一直到 Richard 的 1000 万

00:01:02.320 --> 00:01:08.784
组成的数组

00:01:08.784 --> 00:01:10.329
这是非常快速简单的

00:01:10.329 --> 00:01:13.920
获得键值方法

00:01:13.920 --> 00:01:17.995
我们也可以构建一个 for in 循环来构建数组

00:01:17.995 --> 00:01:19.660
和原来的设置相似

00:01:19.659 --> 00:01:21.724
我们使用 iceCreamTotals 对象

00:01:21.724 --> 00:01:24.384
信息一样 但是这次

00:01:24.385 --> 00:01:27.530
我们将自己创建结果数组

00:01:27.530 --> 00:01:32.368
然后使用 for in 循环迭代访问 iceCreamTotals 对象

00:01:32.368 --> 00:01:37.626
如果检查数组

00:01:37.626 --> 00:01:40.064
就会发现它的输出一样

00:01:40.064 --> 00:01:42.718
我并列比较下二者

00:01:42.718 --> 00:01:46.189
注意 我们自己构建的数组输出

00:01:46.189 --> 00:01:50.599
和之前构建的 Object.keys 调用的输出一样

00:01:50.599 --> 00:01:55.364
使用 Object.keys 的结果和自己循环访问的结果一样

00:01:55.364 --> 00:01:58.119
但是更容易读懂 并且代码更少

