{
  "data": {
    "lesson": {
      "id": 469237,
      "key": "7a95cd0f-752d-422e-b5a4-af8ddeaca0aa",
      "title": "Classes and Objects",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": "Creating objects individually isn't sustainable. Learn how to create similar objects with ease using Classes. You'll also learn how object inheritance works through Prototypal Inheritance.",
      "lesson_type": "Classroom",
      "display_workspace_project_only": null,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/7a95cd0f-752d-422e-b5a4-af8ddeaca0aa/469237/1545053727623/Classes+and+Objects+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/7a95cd0f-752d-422e-b5a4-af8ddeaca0aa/469237/1545053723316/Classes+and+Objects+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 469238,
          "key": "4a452d7b-a495-4a4a-b32e-942910182830",
          "title": "Introduction",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "4a452d7b-a495-4a4a-b32e-942910182830",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 478389,
              "key": "3d4cd5d4-69a6-4a42-ba70-dff647380d6f",
              "title": "OOJS L3 1 - Lesson Overview",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "ZkmB9xKYrVg",
                "china_cdn_id": "ZkmB9xKYrVg.mp4"
              }
            },
            {
              "id": 469240,
              "key": "8e93891d-4230-4a64-bbd6-4cd55c8921e0",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Properties and Methods\n\nWe've been using **properties** and **methods** all up to this point, and in the next section you'll bring your knowledge of object-oriented programming to another level of sophistication by creating **classes** (i.e., _categories_) of objects! \n\nSince an object can represent _data_ and _functionality_, we can use an object to express real-life things (i.e., someone or something) in code. You've seen a few one-off examples throughout the course, but now let's take a deeper dive into it!\n",
              "instructor_notes": ""
            },
            {
              "id": 502461,
              "key": "82e2e8d2-e4fd-4341-a411-f44ac31644eb",
              "title": "OOJS L3 3 - Real-Life Objects - UPDATED",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "2qGt43Ia4qk",
                "china_cdn_id": "2qGt43Ia4qk.mp4"
              }
            },
            {
              "id": 469242,
              "key": "62692609-bc0d-4127-8c01-d67372f3f978",
              "title": "Reflect",
              "semantic_type": "ReflectAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "62692609-bc0d-4127-8c01-d67372f3f978",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "title": null,
                "semantic_type": "TextQuestion",
                "evaluation_id": null,
                "text": "Find something around you and create an object of its properties and methods."
              },
              "answer": {
                "text": "Thanks for taking the time to complete this. Practicing this will help us in the very next section!",
                "video": null
              }
            },
            {
              "id": 478394,
              "key": "e4c927a6-ae3f-40dd-9719-1aea496d6f3e",
              "title": "OOJS L3 5 - Classification Of Objects V1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "pZAL0144Sb4",
                "china_cdn_id": "pZAL0144Sb4.mp4"
              }
            },
            {
              "id": 469244,
              "key": "113b5d48-7801-44b4-9285-e7977f1011b4",
              "title": "",
              "semantic_type": "TaskListAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "113b5d48-7801-44b4-9285-e7977f1011b4",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "tasks": [
                "I have reflected on nearby objects and ways that they can be grouped."
              ],
              "positive_feedback": "Fantastic! Grouping objects based on some criteria is critical when working with classes.",
              "video_feedback": null,
              "description": "Now it's your turn! Take some time to look around your area for objects and reflect on ways that they can be grouped. For example, perhaps a tumbler and a mug each belong to a `Cup` class. Or, maybe a corgi belongs a `Dog` class, and a `sunflower` belongs to a `Flower` class."
            },
            {
              "id": 469245,
              "key": "97d46ab2-fd54-42ee-a9ce-9c84d8316c1f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Object-Oriented Programming\n\nTo recap the above, objects in JavaScript can represent real-life things. That is, objects can have properties to represent _attributes_ or _characteristics_, as well as methods to represent _actions_ that can be performed. Using the analogy of spoken language, you can think of objects as _nouns_, such as a \"dog\" or a \"car.\" Values of properties are _adjectives_, such as \"blue.\" Methods, then, are the verbs, such as \"bark\" or \"drive.\"\n\nIn the next section, we'll take a dive into object-oriented JavaScript, beginning with **constructor functions**. If you've had experience with object-oriented programming in other languages (e.g., Ruby, Python, etc.), you may be surprised to learn that JavaScript does not have a traditional class system (namely, one where the compiler does a lot of organizing out of sight). Instead, the class system is built directly using functions and objects. So rather than using a special class syntax, in JavaScript we define _constructor functions_. Let's dive right in!\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 469246,
          "key": "b1b4a75b-a778-406e-8ab8-45191dc3f8f9",
          "title": "Constructor Functions",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "b1b4a75b-a778-406e-8ab8-45191dc3f8f9",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 478395,
              "key": "9a4bad8d-db7a-4ab4-aea8-ca2b75a2f77b",
              "title": "L3 8 HS - Constructor Functions",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "7XpQpOnkCSk",
                "china_cdn_id": "7XpQpOnkCSk.mp4"
              }
            },
            {
              "id": 469248,
              "key": "907b8bee-304a-4760-b740-8927ca19e34d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Previously, we have created objects using the object literal notation. Likewise, we can even write functions that _return_ objects. There is yet another way for us to create objects, and it is the foundation of object-oriented JavaScript: the **constructor function**. We saw a bit of it back in Lesson 1 when invoking the `Object()` constructor function. Now, let's take a deeper dive into it!\n\nTo instantiate (i.e., _create_) a new object, we use the `new` operator to invoke the function:\n\n```js\nnew SoftwareDeveloper();\n```\n\nThe first thing to note above is the use of the `new` keyword. Second, note that the name of the constructor function, `SoftwareDeveloper()`, is written with the first letter capitalized to _visually_ distinguish it from a regular function. \n\nKeep in mind that even though the function's name starts with a capital, that doesn't _automatically_ make this a constructor function (i.e., though developers name constructor functions in CamelCase by convention, it is _not_ enforced by the language). What _does_ make `SoftwareDeveloper()` a constructor function are:\n\n* The use of the `new` operator to invoke the function\n* How the function is coded internally (which we'll look at right now!)\n\n### Constructor Functions: Structure and Syntax\n\nThis is what the internals of a constructor function looks like:\n\n```js\nfunction SoftwareDeveloper() {\n  this.favoriteLanguage = 'JavaScript';\n}\n```\n\nThis might seem a bit different than the functions you've written up to this point, so let's break it down!\n\nFirst, rather than declaring local variables, constructor functions persist data with the `this` keyword. The above function will add a `favoriteLanguage` property to any object that it creates, and assigns it a default value of `'JavaScript'`. Don't worry too much about `this` in a constructor function for now; just know that `this` refers to the new object that was created by using the `new` keyword in front of the constructor function. We'll go into more detail about `this` soon! \n\nOne last thing that might seem unusual is that this function doesn't seem to return anything! Constructor functions in JavaScript _should not_ have an explicit return value (i.e., there should _not_ be `return` statement).\n\nGreat! Now that we've seen the structure and syntax of a constructor, how can we use it to create an object? \n\n### Creating a New Object\n\nAs we've seen above, let's use the `new` operator to create a new object:\n\n```js\nlet developer = new SoftwareDeveloper();\n```\n\nWe've saved the return value of this invocation to the variable `developer`. Let's execute `console.log(developer);` to log this `SoftwareDeveloper` object to the console:\n",
              "instructor_notes": ""
            },
            {
              "id": 478570,
              "key": "f208678e-860c-471b-b7ff-ce47d9306f36",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/December/5a31c70b_l3-10-object-from-constructor-function/l3-10-object-from-constructor-function.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/f208678e-860c-471b-b7ff-ce47d9306f36",
              "caption": "_The `SoftwareDeveloper` object is logged to the console._",
              "alt": "",
              "width": 936,
              "height": 673,
              "instructor_notes": null
            },
            {
              "id": 478396,
              "key": "6c5b5277-5962-4e4b-9b97-ece7dbab9c4d",
              "title": "L3 -11 - Comparing Objects V1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "EW8avAH_qTs",
                "china_cdn_id": "EW8avAH_qTs.mp4"
              }
            },
            {
              "id": 492719,
              "key": "9216b5f3-3772-47d2-80a1-53344619b810",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "[Here's the code from the preceding video.](https://github.com/udacity/OOJS-screencasts/blob/master/L3-objects-and-classes/11-comparing-objects.js)",
              "instructor_notes": ""
            },
            {
              "id": 469253,
              "key": "3b690c37-8afc-42dc-a585-c67bbac0ac4b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Creating Multiple Objects\n\nWhat's more: we can even use the _same_ constructor function to create as many objects as we'd like!\n\nLet's invoke the same `SoftwareDeveloper()` constructor two more times to instantiate two additional objects: `engineer` and `programmer`.\n\n```js\nlet engineer = new SoftwareDeveloper();\nlet programmer = new SoftwareDeveloper();\n\nconsole.log(engineer);\n// SoftwareDeveloper { favoriteLanguage: 'JavaScript' }\n\nconsole.log(programmer);\n// SoftwareDeveloper { favoriteLanguage: 'JavaScript' }\n```\n",
              "instructor_notes": ""
            },
            {
              "id": 469254,
              "key": "f5a52b62-db3a-4fcd-b310-41b0375c70ea",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Constructor Functions Can Have Parameters\n\nJust like regular functions, one benefit of using constructor functions is that they can also accept arguments. Let's update the constructor above to accept a single argument, and assign the `name` property to it:\n\n```js\nfunction SoftwareDeveloper(name) {\n  this.favoriteLanguage = 'JavaScript';\n  this.name = name;\n}\n```\n\nIn the updated `SoftwareDeveloper()` function, whatever value is passed into the function will be the value of the object's `name` property. Let's check it out:\n\n```js\nlet instructor = new SoftwareDeveloper('Andrew');\n\nconsole.log(instructor);\n// SoftwareDeveloper { favoriteLanguage: 'JavaScript', name: 'Andrew' }\n```\n\nGreat! And as we've seen above, we can create different objects using the same constructor. Let's call the same constructor function but pass a different argument this time:\n\n```js\nlet teacher = new SoftwareDeveloper('Richard');\n\nconsole.log(teacher);\n// SoftwareDeveloper { favoriteLanguage: 'JavaScript', name: 'Richard' }\n```\n\nJust to recap: above, we passed the string `'Richard'` into the `SoftwareDeveloper()` constructor function, then instantiated a new object. `'Richard'` then became the value of the `name` property in the `teacher` object.\n\nLet's check out another example!\n",
              "instructor_notes": ""
            },
            {
              "id": 478397,
              "key": "71c67810-31c7-43de-89bf-c1f28208b46e",
              "title": "L3 - 14 - Instantiating An Object",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "Gg8W66hSfqw",
                "china_cdn_id": "Gg8W66hSfqw.mp4"
              }
            },
            {
              "id": 492745,
              "key": "d4adfb50-39f9-4e25-8799-8aa8307c576c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "[Here's the code from the preceding video.](https://github.com/udacity/OOJS-screencasts/blob/master/L3-objects-and-classes/15-instantiating-an-object.js)",
              "instructor_notes": ""
            },
            {
              "id": 469257,
              "key": "4cb158d5-191b-4d07-8df2-6f6a52e60374",
              "title": "",
              "semantic_type": "CheckboxQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "4cb158d5-191b-4d07-8df2-6f6a52e60374",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Which of the following about constructor functions are true? Constructor functions (select all that apply)...",
                "answers": [
                  {
                    "id": "a1512525887976",
                    "text": "should have a `return` statement",
                    "is_correct": false
                  },
                  {
                    "id": "a1512525899069",
                    "text": "must be invoked with `new`",
                    "is_correct": true
                  },
                  {
                    "id": "a1512525899885",
                    "text": "are used to instantiate a new object",
                    "is_correct": true
                  },
                  {
                    "id": "a1512525901509",
                    "text": "can have at most two parameters/arguments",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 469258,
              "key": "f0ef60fb-5de7-4e55-8ddf-d227e76198c2",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "f0ef60fb-5de7-4e55-8ddf-d227e76198c2",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What happens if a constructor function begins with a lower-case letter?",
                "answers": [
                  {
                    "id": "a1512525944561",
                    "text": "A new object isn't created.",
                    "is_correct": false
                  },
                  {
                    "id": "a1512525953357",
                    "text": "An error occurs.",
                    "is_correct": false
                  },
                  {
                    "id": "a1512525953900",
                    "text": "`this` cannot be used inside a function.",
                    "is_correct": false
                  },
                  {
                    "id": "a1512525954412",
                    "text": "Nothing. It will still work.",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 469259,
              "key": "e8eef5af-d21e-420d-a274-b3e59f21727c",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "e8eef5af-d21e-420d-a274-b3e59f21727c",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "4959760571564032",
                "initial_code_files": [
                  {
                    "text": "/*\n\nNow it's your turn to create a constructor function. Declare a\n`Sandwich` constructor function that takes three parameters:\n\n1. `bread` (string) - the type of bread for the sandwich (e.g. \"Wheat\")\n2. `meat` (array) - the meats to put on the sandwich\n   (e.g. `[]` for a vegetarian sandwich!)\n3. `vegetables` (array) - the vegetables to include in the sandwich\n\n*/\n",
                    "name": "StudentMain.js"
                  }
                ]
              },
              "answer": null
            },
            {
              "id": 469260,
              "key": "1f9e2033-d0f0-40d5-8436-dec604709343",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "> ## ⚠️ Omitting the `new` Operator ⚠️\n>\n> What happens if you inadvertently invoke a constructor function _without_ using the `new` operator?\n>\n>```js\n>function SoftwareDeveloper(name) {\n>    this.favoriteLanguage = 'JavaScript';\n>    this.name = name;\n>}\n>\n>let coder = SoftwareDeveloper('David');\n>\n>console.log(coder);\n>// undefined\n>```\n>\n> What's going on? Without using the `new` operator, no object was created. The function was invoked just like any other regular function. Since the function doesn't _return_ anything (except `undefined`, which all functions return by default), the `coder` variable ended up being assigned to `undefined`.\n>\n> One more thing to note: since this function was invoked as a regular function, the value of `this` is also drastically different. Don't worry too much about this for now; we'll take a deep dive into the `this` keyword in the very next section!\n",
              "instructor_notes": ""
            },
            {
              "id": 469261,
              "key": "0b2bcf63-b8f8-4815-bd64-72bcdaa2fa01",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Seeing the Object's Constructor (`instanceof`)\n\nWhat if we want to see if an object was created with a constructor function in the first place? We can use the `instanceof` (which returns a boolean) to give us some insight. Let's check it out!\n",
              "instructor_notes": ""
            },
            {
              "id": 478398,
              "key": "cf5d226d-b84e-4cdf-9184-367824f748d4",
              "title": "L3 - 21 - How To View Constructor Functions",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "T-b960E8K4I",
                "china_cdn_id": "T-b960E8K4I.mp4"
              }
            },
            {
              "id": 492746,
              "key": "7b9a0296-799e-4820-8335-9f03cc51ee55",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "[Here's the code from the preceding video.](https://github.com/udacity/OOJS-screencasts/blob/master/L3-objects-and-classes/22-how-to-view-constructor-references.js)",
              "instructor_notes": ""
            },
            {
              "id": 469264,
              "key": "33a2b151-e848-442b-86c3-1f6937f7cb26",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "> ## 💡 `instanceof` and the Prototype Chain 💡\n\n>In the above example, `instanceof` confirmed that a specific constructor function did in fact create a specific object. We know this because we directly instantiated the `dev` object after invoking the `Developer()` constructor function.\n\n>Many times, however, it's a bit more complex: the `instanceof` operator actually tests whether or not that constructor appears in the **prototype chain** of an object. This means that we can't always check exactly _which_ constructor created that object, but it does give us insight as to what _other_ properties and methods an object may have access to. \n\n>For now, don't worry too much about the prototype chain or any of these additional properties or methods; we'll take a very close look at them soon!\n",
              "instructor_notes": ""
            },
            {
              "id": 469265,
              "key": "030a7021-d205-46d7-87b1-e650a45363f4",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "030a7021-d205-46d7-87b1-e650a45363f4",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Consider the following constructors:\n\n```js\nfunction Finch(name) {\n  this.kingdom = 'Animalia';\n  this.name = name;\n}\n\nfunction Sparrow(name) {\n  this.kingdom = 'Animalia';\n  this.name = name;\n}\n```\n\nLet's create an instance of each constructor:\n\n\n```js\nconst atticus = new Finch('Atticus');\nconst jack = new Sparrow('Jack');\n```\n\nWhat is the result when `atticus instanceof Sparrow;` is executed?",
                "answers": [
                  {
                    "id": "a1512526118984",
                    "text": "`true`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512526126245",
                    "text": "`false`",
                    "is_correct": true
                  },
                  {
                    "id": "a1512526126733",
                    "text": "`undefined`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512526127333",
                    "text": "`null`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512526129157",
                    "text": "The console throws an error",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 469266,
              "key": "76438baf-26f3-4aaa-9f00-252a751a169a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Summary\n\nJavaScript's class system is built directly on using functions and objects. Calling (i.e., invoking) a **constructor function** with the `new` operator instantiates a new object. The same constructor function can be used to create different objects.\n\nWe've discussed functions, objects, and `this` throughout this course. As it turns out, all three are very much interconnected with one another! We'll examine their relationship in the next section as we take an in-depth look at the `this` keyword.\n",
              "instructor_notes": ""
            },
            {
              "id": 469267,
              "key": "69f8a2c2-c440-4463-907a-695a7c2ed954",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Further Research\n\n* [The new operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new) on MDN\n* [The instanceof operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof) on MDN",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 469268,
          "key": "b10c05b1-bf7b-48bc-83ba-8269540622ed",
          "title": "The `this` Keyword",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "b10c05b1-bf7b-48bc-83ba-8269540622ed",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 478399,
              "key": "595fc666-7401-450f-b27b-2a3b75e37cc6",
              "title": "OOJS L3 27 - This Keyword Intro V2",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "v2yF-ItJdzY",
                "china_cdn_id": "v2yF-ItJdzY.mp4"
              }
            },
            {
              "id": 469270,
              "key": "d1bf66a6-4b8f-4b7e-824d-ecea28a7e63b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## `this` in Constructor Functions\n\nIn the previous section, we saw `this` right inside a constructor function. Here's another example:\n\n```js\nfunction Cat(name) {\n this.name = name;\n this.sayName = function () {\n   console.log(`Meow! My name is ${this.name}`);\n };\n}\n\nconst bailey = new Cat('Bailey');\n```\n\nIn the above `Cat()` constructor, the function that `sayName` references `this.name`. Back in Lesson 1, we saw `this` used in _methods_. But in `Cat()`'s case, what exactly does `this` refer to?\n\nAs it turns out, when invoking a constructor function with the `new` operator, `this` gets set to the _newly-created object_! Let's check out what the new `bailey` object looks like:\n\n```js\n{\n  name: 'Bailey',\n  sayName: function () {\n    console.log(`Meow! My name is ${this.name}`);\n  }\n}\n```\n\nIn the snippet above, notice that `this` is _outside_ a constructor function (i.e., in a method). As we saw in Lesson 1, when you say `this` in a method, what you're really saying is \"this object\" or \"the object at hand.\" As a result, the `sayName()` method can use `this` to access the `name` property of that object! This makes the following method call possible:\n\n```js\nbailey.sayName();\n\n// 'Meow! My name is Bailey'\n```\n\n**Note**: For a refresher on how a method uses `this` to access an object on which it was called, feel free to review **Invoking Object Methods** in Lesson 1. \n",
              "instructor_notes": ""
            },
            {
              "id": 469271,
              "key": "3cf5bb77-1a82-4f96-aa4a-b254f86d7535",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## When is `this` Assigned?\n\nA common misconception is that `this` refers to the object _where it is defined_. This is not the case! \n\nThe value of `this` is actually not assigned to anything until an object calls the method where `this` is used. In other words, the value assigned to `this` is based on _the object that invokes the method where `this` is defined_. Let's look at an example:\n\n```js\nconst dog = {\n  bark: function () {\n    console.log('Woof!');\n  },\n  barkTwice: function () {\n    this.bark();\n    this.bark();\n  }\n};\n```\n\nLet's go ahead and invoke both of `dog`'s methods:\n\n```js\ndog.bark();\n// Woof!\n\ndog.barkTwice();\n// Woof!\n// Woof!\n```\n\nWe know that when we call `dog.bark();` (or `dog.barkTwice();`) a variable `this` gets set. Since `this` can access the object it was called on, `barkTwice` can use `this` to access the `dog` object, which contains the `bark` method.\n\nBut what if we just wrote `bark();` instead of `this.bark();` in `barkTwice`? The function would have first looked for a local variable named `bark` in the scope of `barkTwice`. If `bark` isn't found, it would have looked further up the scope chain.\n\nTo tie things all together: `this.bark();` tells `barkTwice` to look at `dog` -- the object that the method was called on -- to find `bark`.",
              "instructor_notes": ""
            },
            {
              "id": 469272,
              "key": "a0e8022f-ddfc-4755-85af-1677888c2b00",
              "title": "",
              "semantic_type": "CheckboxQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "a0e8022f-ddfc-4755-85af-1677888c2b00",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Time for a quick review! We explored the `this` keyword a bit in Lesson 1, so let's make sure we're on the same page before continuing.\n\nWhat is true about `this`? Select all that apply:",
                "answers": [
                  {
                    "id": "a1512526525624",
                    "text": "`this` refers to \"this property,\" or \"this method\"",
                    "is_correct": false
                  },
                  {
                    "id": "a1512526545326",
                    "text": "Using `this`, methods can access and manipulate an object's properties",
                    "is_correct": true
                  },
                  {
                    "id": "a1512526546013",
                    "text": "The exact value of `this` is already set before a method is invoked",
                    "is_correct": false
                  },
                  {
                    "id": "a1512526546510",
                    "text": "`this` is a reserved word in JavaScript",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 469273,
              "key": "b512e86a-413a-4664-9d45-43940ed8b3ec",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "b512e86a-413a-4664-9d45-43940ed8b3ec",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Consider the following constructor function, `City`:\n\n```js\nfunction City(name, population) {\n  this.name = name;\n  this.population = population;\n\n  this.identify = function () {\n    console.log(`${this.name}'s population is ${this.population}.`);\n  };\n}\n```\nThe following is executed:\n\n```js\nconst sanFrancisco = new City('San Francisco', 870000);\n```\n\nWhat is the value of `this`?\n",
                "answers": [
                  {
                    "id": "a1512526672498",
                    "text": "`City`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512526678454",
                    "text": "Any property (such as `name`, or `population`)",
                    "is_correct": false
                  },
                  {
                    "id": "a1512526678942",
                    "text": "`undefined`, because `this` must always be inside an _object_ (i.e., in a method), not a constructor function",
                    "is_correct": false
                  },
                  {
                    "id": "a1512526679422",
                    "text": "The newly-created object, referenced by `sanFrancisco`",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 469274,
              "key": "cf0692be-0881-4154-95c5-3f4dae376a80",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## What Does `this` Get Set To?\n\nAt this point, we've seen `this` in many different contexts, such as within a method, or referenced by a constructor function. Let's now organize our thoughts and bring it all together!\n\nThere are four ways to call functions, and each way sets `this` differently.\n\nFirst, calling a constructor function with the `new` keyword sets `this` to a newly-created object. Recall that creating an instance of `Cat` earlier had set `this` to the new `bailey` object. \n\nOn the other hand, calling a function that belongs to an object (i.e., a _method_) sets `this` to the object itself. Recall that earlier, the `dog` object's `barkTwice()` method was able to access properties of `dog` itself.\n\nThird, calling a function on its own (i.e., simply invoking a regular function) will set `this` to `window`, which is the global object if the host environment is the browser. \n\n```js\nfunction funFunction() {\n  return this;\n}\n\nfunFunction();\n// (returns the global object, `window`)\n```\n\nThe fourth way to call functions allows us to set `this` ourselves! Don't worry about this approach for now; we'll take a deep dive in the very next section.\n\nWhew -- that was a lot of `this`! Let's compartmentalize these findings in the video below:\n",
              "instructor_notes": ""
            },
            {
              "id": 478400,
              "key": "18a2103d-8f6f-464f-8717-778385b6b128",
              "title": "OOJS L3 33 - 'This' Grid V1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "Xwfi1wCB8OM",
                "china_cdn_id": "Xwfi1wCB8OM.mp4"
              }
            },
            {
              "id": 478571,
              "key": "cdec25eb-99ef-45e8-9647-7550ed4e2ad0",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/December/5a31c70c_l3-53-this-grid-2/l3-53-this-grid-2.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/cdec25eb-99ef-45e8-9647-7550ed4e2ad0",
              "caption": "_If a constructor function is called with the `new` operator, the value of `this` is set to the newly-created object. If a method is invoked on an object, `this` is set to that object itself. And if a function is simply invoked, `this` is set to the global object: `window`._",
              "alt": "",
              "width": 613,
              "height": 152,
              "instructor_notes": null
            },
            {
              "id": 469277,
              "key": "6f5a725e-65f7-465f-a333-23835f954a7c",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "6f5a725e-65f7-465f-a333-23835f954a7c",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Consider the following object, `building`:\n\n```js\nconst building = {\n  floors: 5,\n  addFloor: function () {\n    this.floors += 1;\n  }\n};\n\nbuilding.addFloor();\n// ???\n```\n\nWhat is the value of `this` when `building.addFloor();` is executed?",
                "answers": [
                  {
                    "id": "a1512526812842",
                    "text": "`window`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512526841982",
                    "text": "`building`",
                    "is_correct": true
                  },
                  {
                    "id": "a1512526842486",
                    "text": "`undefined`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512526842919",
                    "text": "`addFloor()` will return an error because `this.floors += 1;` cannot be resolved",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 469278,
              "key": "260a30b4-4c25-4880-b93d-8d474afb7faf",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "260a30b4-4c25-4880-b93d-8d474afb7faf",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Consider the following:\n\n```js\nfunction myFunction() {\n  console.log(\"What is the value of 'this'?\");\n}\n\nmyFunction();\n// ???\n```\n\nWhen `myFunction();` is executed, what is the value of the `this` keyword?",
                "answers": [
                  {
                    "id": "a1512526911753",
                    "text": "`myFunction`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512526917799",
                    "text": "`undefined`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512526918327",
                    "text": "`this` does not get set to any value when a function is invoked",
                    "is_correct": false
                  },
                  {
                    "id": "a1512526918807",
                    "text": "`window`",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 469279,
              "key": "37fcd96b-3d3c-4d7a-996a-9a99bccb0b1d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Summary\n\nFunctions, objects, and `this` are all interconnected. When invoking constructor functions with the `new` operator, a `this` variable is set to the newly-created object. When invoking a method on an object, `this` is set to that object itself. And when invoking a function in a browser environment, `this` is set to `window`, otherwise known as the global object.\n\nAlong with all this, there is yet one more set of ways to invoke functions: with `apply()`, and with `call()`. Both methods share quite a few similarities, and they each allow us to specify how we want to set `this`. We'll take a look at each of them in detail next!\n",
              "instructor_notes": ""
            },
            {
              "id": 469280,
              "key": "0e3fd5a7-2fec-4203-b9ac-52a0fed99058",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Further Research\n\n* [The this operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) on MDN",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 469281,
          "key": "f55148aa-4cb0-423a-8589-e85d99535919",
          "title": "Setting Our Own `this`",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "f55148aa-4cb0-423a-8589-e85d99535919",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 469282,
              "key": "d41ff1b4-bffb-44b3-8dfe-912bdb34fb6e",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Recall that functions, objects, and the `this` keyword are all interconnected. Whether you're invoking a constructor function with the `new` operator, invoking a method on an object, or simply invoking a function normally -- each form of invocation sets the value of `this` a bit differently.\n\nBut what if we want to set the value of `this` ourselves? JavaScript offers a few methods that can do just that!\n",
              "instructor_notes": ""
            },
            {
              "id": 478402,
              "key": "1a907a3f-f383-4482-acb9-4773b2faa3ef",
              "title": "OOJS L3 40 - Setting Own This Intro V1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "jMEwWv5hkYI",
                "china_cdn_id": "jMEwWv5hkYI.mp4"
              }
            },
            {
              "id": 469284,
              "key": "16b48a6e-d328-446b-b415-b4c3d43ea51d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## More Ways to Invoke Functions\n\nWe've seen various ways to invoke functions, each with their own implications regarding the value of `this`. There are yet two more ways to invoke a function: either using the `call()` or the `apply()` methods. \n\nEach method can be directly invoked onto a function itself (after all, JavaScript functions are _first-class_ functions and can have properties and methods). As a result, the _receiving_ function will be invoked with a specified `this` value, as well as any arguments passed in. \n\nLet's take a closer look at each of these methods, starting with `call()`!\n\n### call()\n\n`call()` is a method directly invoked onto a function. We first pass into it a single value to set as the value of `this`; then we pass in any of the receiving function's arguments one-by-one, separated by commas. \n\nConsider the following function, `multiply()`, which simply returns the product of its two arguments:\n\n```js\nfunction multiply(n1, n2) {\n  return n1 * n2;\n}\n```\n\nLet's invoke it in the console:\n\n```js\nmultiply(3, 4);\n\n// 12\n```\n\nNo surprises here! But now -- let's use the `call()` method to invoke the same function:\n\n```js\nmultiply.call(window, 3, 4);\n\n// 12\n```\n\nWe get the same result! How did this happen? We first invoke the `call()` method directly onto the `multiply()` function. Note that the `multiply` preceding `.call(window, 3, 4)` is not followed by any parentheses. `call()` will be handling the invocation _and_ the `multiply()` function's arguments itself!\n\nAfter writing that part, it's time to pass in the arguments! For the first argument of the `call()` method, we pass in the value to be set as `this`, which is `window`. We then finish up by passing in the `multiply()` function's arguments individually, _separated by commas_. \n\nOnce `multiply.call(window, 3, 4);` executes, the function will be invoked with the given value of `this`, and the result that we see is `12`. Outside of [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode), both ways of invoking `multiply()` above are equivalent.\n\nAlong with invoking regular functions, how do we go upon invoking _functions attached to objects_ (i.e., methods)? This is where the power of `call()` really shines. Using `call()` to invoke a method allows us to \"borrow\" a method from one object -- then use it for _another_ object! Check out the following object, `mockingbird`:\n\n```js\nconst mockingbird = {\n  title: 'To Kill a Mockingbird',\n  describe: function () {\n    console.log(`${this.title} is a classic novel`);\n  }\n};\n```\n\nWe can have `mockingbird` invoke its own `describe()` method:\n\n```js\nmockingbird.describe();\n\n// 'To Kill a Mockingbird is a classic novel'\n```\n\nUsing `call()`, however, the following `pride` object can utilize `mockingbird`'s `describe()` method:\n\n```js\nconst pride = {\n  title: 'Pride and Prejudice'\n};\n\nmockingbird.describe.call(pride);\n// 'Pride and Prejudice is a classic novel'\n```\n\nLet's break down what happened when `mockingbird.describe.call(pride);` is executed! \n\nFirst, the `call()` method is invoked onto `mockingbird.describe` (which points to a function). Then, the value of `this` is passed into the `call()` method: `pride`. \n\nSince `mockingbird`'s `describe()` method references `this.title`, we need to access the `title` property of the object that `this` refers to. But since we've set our own value of `this`, the value of `this.title` will be accessed from the `pride` object! As a result, `mockingbird.describe.call(pride);` is executed, and we see `'Pride and Prejudice is a classic novel'` in the console.\n\n`call()` is very effective if you're looking to invoke a function in the scope of the first argument passed into it. Likewise, we can leverage the `apply()` method to do the same, albeit with differences in how arguments are passed into it. Let's take a closer look!\n\n### apply()\n\nJust like `call()`, the `apply()` method is called on a function to not only invoke that function, but also to associate with it a specific value of `this`. However, rather than passing arguments one-by-one, separated by commas -- `apply()` takes the function's arguments in an _array_.  Recall the `multiply()` function from earlier:\n\n```js\nfunction multiply(n1, n2) {\n  return n1 * n2;\n}\n```\n\nWe used `call()` and passed in arguments individually:\n\n```js\nmultiply.call(window, 3, 4);\n\n// 12\n```\n\nUsing `apply()`, however, we collect all of the `multiply()` function's arguments in an _array_! Then, we pass that entire array into `apply()`:\n\n```js\nmultiply.apply(window, [3, 4]);\n\n// 12\n```\n\nGreat! Note that the first argument in both `call()` and `apply()` is still `window` (i.e., the object to bind the value of `this` to). \n\nNow what about invoking an object's method with `apply()`? Recall the previous `mockingbird` and `pride` objects:\n\n```js\nconst mockingbird = {\n  title: 'To Kill a Mockingbird',\n  describe: function () {\n    console.log(`${this.title} is a classic novel`);\n  }\n};\n\n\nconst pride = {\n  title: 'Pride and Prejudice'\n};\n```\n\nPreviously, we used `call()` to allow the `pride` object to \"borrow\" `mockingbird`'s `describe()` method:\n\n```js\nmockingbird.describe.call(pride);\n\n// 'Pride and Prejudice is a classic novel'\n```\n\nWe can achieve the same result using `apply()`!\n\n```js\nmockingbird.describe.apply(pride);\n\n// 'Pride and Prejudice is a classic novel'\n```\n\nNote that the first argument passed into both `call()` and `apply()` is the same: `pride`. Since the `describe()` method doesn't take any arguments, the only difference between `mockingbird.describe.call(pride);` and `mockingbird.describe.apply(pride);` is just the method! Both approaches produce the same result.\n",
              "instructor_notes": ""
            },
            {
              "id": 469285,
              "key": "ed0694b6-a2ee-4025-b0ab-84169fc1e5e6",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Choosing One Method Over the Other\n\nBoth `call()` and `apply()` invoke a function in the scope of the first argument passed in them (i.e., the object to be the value of `this`). So when would you choose `call()` over `apply()`, or vice versa? \n\n`call()` may be limited if you don't know ahead of time the number of arguments that the function needs. In this case, `apply()` would be a better option, since it simply takes an array of arguments, then unpacks them to pass along to the function. Keep in mind that the unpacking comes at a minor performance cost, but it shouldn't be much of an issue.\n\nLet's now see `call()` and `apply()` in action!",
              "instructor_notes": ""
            },
            {
              "id": 478403,
              "key": "a2d09968-4657-4eed-be23-0be652704e0a",
              "title": "L3 - 42 - Invoking Functions Demo",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "rHMH0budUKk",
                "china_cdn_id": "rHMH0budUKk.mp4"
              }
            },
            {
              "id": 492747,
              "key": "8e1768f2-baa3-4dad-82ed-4f5cbbdc6d86",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "[Here's the code from the preceding video.](https://github.com/udacity/OOJS-screencasts/blob/master/L3-objects-and-classes/44-invoking-functions-demo.js)",
              "instructor_notes": ""
            },
            {
              "id": 469288,
              "key": "a4695b8c-a429-45ac-af81-8037c77000e8",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "a4695b8c-a429-45ac-af81-8037c77000e8",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Consider the following `dave` object, and the `sayHello()` function:\n\n```js\nconst dave = {\n  name: 'Dave'\n};\n\nfunction sayHello(message) {\n  console.log(`${message}, ${this.name}. You're looking well today.`);\n}\n```\n\nLet's say you want the message `'Hello, Dave. You're looking well today.'` printed to the console. \n\nWhich of the following expressions could you write to accomplish that?\n",
                "answers": [
                  {
                    "id": "a1512527239841",
                    "text": "`dave.apply(sayHello('Hello'));`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512527247167",
                    "text": "`dave.sayHello('Hello');`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512527247647",
                    "text": "`sayHello.apply(dave, ['Hello']);`",
                    "is_correct": true
                  },
                  {
                    "id": "a1512527248007",
                    "text": "It is not possible. `sayHello()` _must_ be called as a method (i.e., invoked onto an object directly) in order to set `this` properly.",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 469289,
              "key": "f2fa839e-ed50-4184-85f6-73d574d0a48f",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "f2fa839e-ed50-4184-85f6-73d574d0a48f",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Consider the following `Andrew` and `Richard` objects:\n\n```js\nconst Andrew = {\n  name: 'Andrew',\n  introduce: function () {\n    console.log(`Hi, my name is ${this.name}!`);\n  }\n};\n```\n```js\nconst Richard = {\n  name: 'Richard',\n  introduce: function () {\n    console.log(`Hello there! I'm ${this.name}.`);\n  }\n};\n```\n\nWhen `Richard.introduce.call(Andrew);` is executed, what is logged to the console?",
                "answers": [
                  {
                    "id": "a1512527328563",
                    "text": "`'Hello there! I'm Andrew.'`",
                    "is_correct": true
                  },
                  {
                    "id": "a1512527383879",
                    "text": "`'Hello there! I'm Richard.'`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512527384327",
                    "text": "`'Hi, my name is Richard!'`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512527384895",
                    "text": "`'Hi, my name is Andrew!'`",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 469290,
              "key": "ce985949-5f53-4b9a-b9ce-df52b9b25b13",
              "title": "",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "ce985949-5f53-4b9a-b9ce-df52b9b25b13",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Consider the following:\n\n```js\nconst andrew = {\n  name: 'Andrew'\n};\n\nfunction introduce(language) {\n  console.log(`I'm ${this.name} and my favorite programming language is ${language}.`);\n}\n```\n\nWrite an expression that uses the `call()` method to produce the message: `'I'm Andrew and my favorite programming language is JavaScript.'`\n",
                "matchers": [
                  {
                    "expression": "^introduce\\.call\\( ?andrew\\, ?['\"]JavaScript['\"] ?\\);?\\n?$"
                  }
                ]
              }
            },
            {
              "id": 469291,
              "key": "f12a7c9a-184f-4219-affb-e22dd855fc35",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Callbacks and `this`\n\nThe value of `this` has some potential scope issues when _callback functions_ are involved, and things can get a bit tricky. Let's check it out below.\n",
              "instructor_notes": ""
            },
            {
              "id": 478474,
              "key": "bd7148bb-a37e-4b34-9dea-e07f4c7a96f4",
              "title": "L3 -49 - Callbacks And This Demo V1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "r7bmNJHFttE",
                "china_cdn_id": "r7bmNJHFttE.mp4"
              }
            },
            {
              "id": 492748,
              "key": "17631cea-ee51-418e-98f9-24265ea10210",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "[Here's the code from the preceding video.](https://github.com/udacity/OOJS-screencasts/blob/master/L3-objects-and-classes/50-callbacks-and-this-demo.js)",
              "instructor_notes": ""
            },
            {
              "id": 469294,
              "key": "77ea9d4d-62ad-40ba-b077-be079f57d649",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Saving `this` with an Anonymous Closure\n\nLet's recap the issue at hand. Here's the `invoiceTwice()` function from the previous video, as well as the `dog` object:\n\n```js\nfunction invokeTwice(cb) {\n   cb();\n   cb();\n}\n\nconst dog = {\n  age: 5,\n  growOneYear: function () {\n    this.age += 1;\n  }\n};\n```\n\nFirst, invoking `growOneYear()` works as expected, updating the value of the `dog` object's `age` property from `5` to `6`:\n\n```js\ndog.growOneYear();\n\ndog.age; \n// 6\n```\n\nHowever, passing `dog.growOneYear` (a function) as an argument into `invokeTwice()` produces an odd result:\n\n```js\ninvokeTwice(dog.growOneYear);\n\ndog.age;\n// 6\n```\n\nYou may have expected the value of the `age` property in `dog` to have increased to `8`. Why did it remain `6`? \n\nAs it turns out, `invokeTwice()` does indeed invoke `growOneYear` -- but it is invoked as a _function_ rather than a _method_! Let's revisit the `this` grid from earlier:\n",
              "instructor_notes": ""
            },
            {
              "id": 478572,
              "key": "329ef863-fd8d-45f2-a944-26712b51197e",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/December/5a31c70c_l3-53-this-grid-2/l3-53-this-grid-2.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/329ef863-fd8d-45f2-a944-26712b51197e",
              "caption": "_If a constructor function is called with the `new` operator, the value of `this` is set to the newly-created object. If a method is invoked on an object, `this` is set to that object itself. And if a function is simply invoked, `this` is set to the global object: `window`._",
              "alt": "",
              "width": 613,
              "height": 152,
              "instructor_notes": null
            },
            {
              "id": 469296,
              "key": "6313be31-a04e-4b3b-86c6-0cc4b79b8b3a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Saving `this` with an Anonymous Closure\n\nRecall that simply invoking a normal function will set the value of `this` to the global object (i.e., `window`). This is an issue, because we want `this` to be the `dog` object! \n\nSo how can we make sure that `this` is preserved?\n\nOne way to resolve this issue is to use an **anonymous closure** to close over the `dog` object:\n\n```js\ninvokeTwice(function () { \n  dog.growOneYear(); \n});\n\ndog.age;\n// 7\n```\n\nUsing this approach, invoking `invokeTwice()` still sets the value of `this` to `window`. However, this has no effect on the closure; within the anonymous function, the `growOneYear()` method will still be directly called onto the `dog` object! As a result, the value of `dog`'s `age` property increases from `5` to `7`.\n\nSince this is such a common pattern, JavaScript provides an alternate and less verbose approach: the `bind()` method.\n",
              "instructor_notes": ""
            },
            {
              "id": 469297,
              "key": "b548082f-b84d-425e-829b-81a8748930eb",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Saving `this` with bind()\n\nSimilar to `call()` and `apply()`, the `bind()` method allows us to directly define a value for `this`. `bind()` is a method that is also called _on_  a function, but unlike `call()` or `apply()`, which both invoke the function right away -- `bind()` _returns_ a new function that, when called, has `this` set to the value we give it.\n\nLet's see it in action!\n",
              "instructor_notes": ""
            },
            {
              "id": 478475,
              "key": "046b714d-ed33-4c93-a7b6-ca4d26c56a3e",
              "title": "L3 - 52 - Using Bind V1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "t225UNDPO9c",
                "china_cdn_id": "t225UNDPO9c.mp4"
              }
            },
            {
              "id": 492749,
              "key": "d010387c-7b9a-425f-b277-85e76c2fda33",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "[Here's the code from the preceding video.](https://github.com/udacity/OOJS-screencasts/blob/master/L3-objects-and-classes/56-using-bind.js)",
              "instructor_notes": ""
            },
            {
              "id": 469300,
              "key": "53991a37-7646-42b4-a3f1-928b3ee80074",
              "title": "",
              "semantic_type": "CheckboxQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "53991a37-7646-42b4-a3f1-928b3ee80074",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is true about `bind()`? Select all that apply:",
                "answers": [
                  {
                    "id": "a1512527951804",
                    "text": "`bind()` is a method that is called on a function",
                    "is_correct": true
                  },
                  {
                    "id": "a1512527958504",
                    "text": "`bind()` returns a new function that, when called, has `this` set to the provided object",
                    "is_correct": true
                  },
                  {
                    "id": "a1512527959008",
                    "text": " The object passed into `bind()` _must_ be the same as the object on which the method was called (e.g., `dog.growOneYear.bind(dog);`)",
                    "is_correct": false
                  },
                  {
                    "id": "a1512527959407",
                    "text": "`bind()` _invokes_ a function, so it can be substituted with `call()` and `apply()`",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 469301,
              "key": "9fd60a08-2b7f-4b3f-92d0-b0525fecc407",
              "title": "",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "9fd60a08-2b7f-4b3f-92d0-b0525fecc407",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Consider the following:\n\n```js\nconst driver = {\n  name: 'Danica',\n  displayName: function () {\n    console.log(`Name: ${this.name}`);\n  }\n};\n\nconst car = {\n  name: 'Fusion'\n};\n```\n\nWrite an expression using `bind()` that allows us to \"borrow\" the `displayName()` method from `driver` for the `car` object to use. Note: The _expression itself_ is sufficient (no need to save it to a variable).",
                "matchers": [
                  {
                    "expression": "^driver\\.displayName\\.bind\\( ?car ?\\);?\\n?$"
                  }
                ]
              }
            },
            {
              "id": 469302,
              "key": "d416927f-6c83-4c25-b538-6149e75f5536",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Summary\n\nJavaScript provides three methods that allow us to set the value of `this` for a given function:\n\n* `call()` invokes the function and has arguments passed in individually, separated by commas.\n* `apply()` is similar to `call()`; it invokes the function just the same, but arguments are passed in as an array.\n* `bind()` returns a new function with `this` bound to a specific object, allowing us to call it as a regular function.\n\nFor further research, we recommend checking out Kyle Simpson's **You Don't Know JS** series on `this`, linked below.\n\nAt this point, you've seen how functions, objects, and the `this` keyword are all very much interconnected. You've also seen how just about _everything_ in JavaScript is an object! \n\nDid you know that you can even base _objects_ on _other objects_? This is the main idea behind **prototypal inheritance**, and by implementing it, objects can take on properties of _other objects_. We'll cover all this and more, coming up next!\n",
              "instructor_notes": ""
            },
            {
              "id": 469303,
              "key": "c83cffa7-5124-4d9a-a938-f16c96bc53db",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Further Research\n\n* Kyle Simpson's [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes)\n* [call()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call) on MDN\n* [apply()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) on MDN\n* [bind()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) on MDN",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 469304,
          "key": "ab0184cb-2341-4ece-91f9-8c1a971769d0",
          "title": "Prototypal Inheritance",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "ab0184cb-2341-4ece-91f9-8c1a971769d0",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 478407,
              "key": "22d81c96-5f31-4923-afd3-aaf87efd60b1",
              "title": "OOJS L3 59 - Prototypal Inheritence V2",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "KdHMZEzRI4s",
                "china_cdn_id": "KdHMZEzRI4s.mp4"
              }
            },
            {
              "id": 469306,
              "key": "bb3fe7bd-3e0f-4bec-ac2b-37f9867a4949",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Adding Methods to the Prototype\n\nRecall that objects contain data (i.e., properties), as well as the means to manipulate that data (i.e., methods). Earlier in this Lesson, we simply added methods _directly_ into the constructor function itself:\n\n```js\nfunction Cat(name) {\n this.lives = 9;\n this.name = name;\n\n this.sayName = function () {\n   console.log(`Meow! My name is ${this.name}`);\n };\n}\n```\n\nThis way, a `sayName` method gets added to all `Cat` objects by saving a function to the `sayName` attribute of newly-created `Cat` objects. \n\nThis works just fine, but what if we want to instantiate more and more `Cat` objects with this constructor? You'll create a new function every single time for that `Cat` object's `sayName`! What's more: if you ever want to make changes to the method, you'll have to update all objects _individually_. In this situation, it makes sense to have all objects created by the same `Cat` constructor function just _share_ a single `sayName` method.\n\nTo save memory and keep things DRY, we can add methods to the constructor function's `prototype` property. The prototype is just an object, and all objects created by a constructor function keep a reference to the prototype. Those objects can even use the `prototype`'s properties _as their own_!\n\nJavaScript leverages this secret link -- between an object and its prototype -- to implement inheritance. Consider the following prototype chain:\n",
              "instructor_notes": ""
            },
            {
              "id": 478573,
              "key": "f6063a85-1a7c-42cb-8134-c7da566b0fdd",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/December/5a31c70c_l3-64-prototype-chain-diagram/l3-64-prototype-chain-diagram.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/f6063a85-1a7c-42cb-8134-c7da566b0fdd",
              "caption": "_The `Cat()` constructor function is invoked using the `new` operator, which creates the `bailey` instance (object). Note that the `meow()` method is defined in the prototype of the `bailey` object's constructor function. The prototype is just an object, and all objects created by that constructor are secretly linked to the prototype. As such, we can execute `bailey.meow()` as if it were `bailey`'s own method!_",
              "alt": "",
              "width": 943,
              "height": 233,
              "instructor_notes": null
            },
            {
              "id": 469310,
              "key": "a9ffbc94-6180-4469-a649-0c82fc6fd8a7",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Recall that each function has a `prototype` property, which is really just an object. When this function is invoked as a constructor using the `new` operator, it creates and returns a new object. This object is secretly linked to its constructor's `prototype`, and this secret link allows the object to access the `prototype`'s properties and methods as if it were its own!\n\nSince we know that the `prototype` property just points to a regular object, _that_ object itself also has a secret link to _its_ prototype. And _that_ prototype object also has reference to _its own_ prototype -- and so on. This is how the **prototype chain** is formed.\n\n## Finding Properties and Methods on the Prototype Chain\n\nWhether you're accessing a property (e.g., `bailey.lives;`) or invoking a method (e.g., `bailey.meow();`), the JavaScript interpreter looks for them along the prototype chain in a very particular order:\n\n1. First, the JavaScript engine will look at the object's _own_ properties. This means that any properties and methods defined directly in the object itself will take precedence over any properties and methods elsewhere if their names are the same (similar to variable shadowing in the _scope chain_).\n2. If it doesn't find the property in question, it will then search the object's constructor's prototype for a match.\n3. If the property doesn't exist in the prototype, the JavaScript engine will continue looking up the chain.\n4. At the very end of the chain is the `Object()` object, or the top-level parent. If the property _still_ cannot be found, the property is undefined.\n\nPreviously, we simply defined methods directly in a constructor function itself. Let's see how things look if we defined methods in the constructor's `prototype` instead!\n",
              "instructor_notes": ""
            },
            {
              "id": 492737,
              "key": "8745d05f-a651-4322-b8a9-aeb3a35f0e02",
              "title": "L3- 62 - Methods And Prototype FIXED",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "Vx_LcB0sQDE",
                "china_cdn_id": "Vx_LcB0sQDE.mp4"
              }
            },
            {
              "id": 492751,
              "key": "71563303-53e7-491a-8f05-f75c8dc6d5ca",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "[Here's the code from the preceding video.](https://github.com/udacity/OOJS-screencasts/blob/master/L3-objects-and-classes/66-methods-and-prototype.js)",
              "instructor_notes": ""
            },
            {
              "id": 469312,
              "key": "ba8ef624-3b1f-4514-a1a8-63cdcbb522b0",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "For the next quiz, consider the following two code snippets below (i.e., A and B):\n\n```js\n// (A)\n\nfunction Dalmatian (name) {\n  this.name = name;\n\n  this.bark = function() {\n    console.log(`${this.name} barks!`);\n  };\n}\n```\n\n\n```js\n// (B)\n\nfunction Dalmatian (name) {\n  this.name = name;\n}\n\nDalmatian.prototype.bark = function() {\n  console.log(`${this.name} barks!`);\n};\n```",
              "instructor_notes": ""
            },
            {
              "id": 469313,
              "key": "da9be44d-534e-4b8c-b8a6-6b2f3fe68970",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "da9be44d-534e-4b8c-b8a6-6b2f3fe68970",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Let's say that we want to define a method that can be invoked on instances (objects) of the `Dalmatian` constructor function (we'll be instantiating at least 101 of them!). \n\nWhich of the preceding two approaches is optimal?",
                "answers": [
                  {
                    "id": "a1512528662644",
                    "text": "**(A)** is optimal, because `bark()` can be called directly on an instance of `Dalmatian`. In (B), `bark()` needs to be called on the `Dalmatian` instance's prototype for the method to be properly invoked (e.g., spotty.prototype.bark()).",
                    "is_correct": false
                  },
                  {
                    "id": "a1512528683849",
                    "text": "**(B)** is optimal, because the function that `bark` points to does not need to be recreated each time an instance of `Dalmatian` is created.",
                    "is_correct": true
                  },
                  {
                    "id": "a1512528684552",
                    "text": "**(A)** is optimal, because all methods should always be enclosed within the `Dalmatian()` constructor function itself.",
                    "is_correct": false
                  },
                  {
                    "id": "a1512528685040",
                    "text": "Both approaches (both **(A)** and **(B)**) are equal; there are no differences.",
                    "is_correct": false
                  },
                  {
                    "id": "a1512528701936",
                    "text": "None. Methods should always be manually added to individual instances of `Dalmatian`. ",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 469314,
              "key": "1c20da7b-aed3-49c4-806d-87c3f63b4dd7",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### 💡 Replacing the `prototype` Object 💡\n\nWhat happens if you completely replace a function's `prototype` object? How does this affect objects created by that function? Let's look at a simple `Hamster` constructor function and instantiate a few objects:\n\n```js\nfunction Hamster() {\n  this.hasFur = true;\n}\n\nlet waffle = new Hamster();\nlet pancake = new Hamster();\n```\n\nFirst, note that even after we make the new objects, `waffle` and `pancake`, we can still add properties to `Hamster`'s prototype and it will still be able to access those new properties.\n\n```js\nHamster.prototype.eat = function () {\n  console.log('Chomp chomp chomp!');\n};\n\nwaffle.eat();\n// 'Chomp chomp chomp!'\n\npancake.eat();\n// 'Chomp chomp chomp!'\n```\n\nNow, let's replace `Hamster`'s `prototype` object with something else entirely:\n\n```js\nHamster.prototype = {\n  isHungry: false,\n  color: 'brown'\n};\n```\n\nThe previous objects don't have access to the updated prototype's properties; they just retain their secret link to the old prototype:\n\n```js\nconsole.log(waffle.color);\n// undefined\n\nwaffle.eat();\n// 'Chomp chomp chomp!'\n\nconsole.log(pancake.isHungry);\n// undefined\n```\n\nAs it turns out, any new `Hamster` objects created moving forward will use the updated prototype:\n\n```js\nconst muffin = new Hamster();\n\nmuffin.eat();\n// TypeError: muffin.eat is not a function\n\nconsole.log(muffin.isHungry);\n// false\n\nconsole.log(muffin.color);\n// 'brown'\n```\n",
              "instructor_notes": ""
            },
            {
              "id": 478409,
              "key": "c091e7e5-b49d-415a-bfbf-a47f469343e2",
              "title": "L3 - 70 - Prototype Demo",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "MaNixLkrYTE",
                "china_cdn_id": "MaNixLkrYTE.mp4"
              }
            },
            {
              "id": 492752,
              "key": "0895a247-758b-4473-a5c1-1ba0ec72fa50",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "[Here's the code from the preceding video.](https://github.com/udacity/OOJS-screencasts/blob/master/L3-objects-and-classes/72-prototype-demo.js)",
              "instructor_notes": ""
            },
            {
              "id": 469317,
              "key": "7387a53b-ab93-4673-b8c2-adf38e5465eb",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Checking an Object's Properties\n\nAs we've just seen, if an object doesn't have a particular property of its own, it can access one somewhere along the prototype chain (assuming it _exists_, of course). With so many options, it can sometimes get tricky to tell just _where_ a particular property is coming from! Here are a few useful methods to help you along the way.\n\n### hasOwnProperty()\n\n`hasOwnProperty()` allows you to find the origin of a particular property. Upon passing in a string of the property name you're looking for, the method will return a boolean indicating whether or not the property belongs to the object itself (i.e., that property was _not_ inherited). Consider the `Phone` constructor with a single property defined directly in the function, and another property on its `prototype` object:\n\n```js\nfunction Phone() {\n  this.operatingSystem = 'Android';\n}\n\nPhone.prototype.screenSize = 6;\n```\n\nLet's now create a new object, `myPhone`, and check whether `operatingSystem` is its own property, meaning that it was not inherited from its prototype (or somewhere else along the prototype chain):\n\n```js\nconst myPhone = new Phone();\n\nconst own = myPhone.hasOwnProperty('operatingSystem');\n\nconsole.log(own);\n// true\n```\n\nIndeed it returns true! What about the `screenSize` property, which exists on `Phone` objects' `prototype`?\n\n```js\nconst inherited = myPhone.hasOwnProperty('screenSize');\n\nconsole.log(inherited);\n// false\n```\n\nUsing `hasOwnProperty()`, we gain insight a certain property's origins.\n\n### isPrototypeOf()\n\nObjects also have access to the `isPrototypeOf()` method, which checks whether or not an object exists in another object's prototype chain. Using this method, you can confirm if a particular object serves as the prototype of another object. Check out the following `rodent` object:\n\n```js\nconst rodent = {\n  favoriteFood: 'cheese',\n  hasTail: true\n};\n```\n\nLet's now build a `Mouse()` constructor function, and assign its `prototype` to `rodent`:\n\n```js\nfunction Mouse() {\n  this.favoriteFood = 'cheese';\n}\n\nMouse.prototype = rodent;\n```\n\nIf we create a new `Mouse` object, its prototype should be the `rodent` object. Let's confirm:\n\n```js\nconst ralph = new Mouse();\n\nconst result = rodent.isPrototypeOf(ralph);\n\nconsole.log(result);\n// true\n```\n\nGreat! `isPrototypeOf()` is a great way to confirm if an object exists in another object's prototype chain.\n\n### Object.getPrototypeOf()\n\n`isPrototypeOf()` works well, but keep in mind that in order to use it, you must _have_ that prototype object at hand in the first place! What if you're not sure what a certain object's prototype is? `Object.getPrototypeOf()` can help with just that!\n\nUsing the previous example, let's store the return value of `Object.getPrototypeOf()` in a variable, `myPrototype`, then check what it is:\n\n```js\nconst myPrototype = Object.getPrototypeOf(ralph);\n\nconsole.log(myPrototype);\n// { favoriteFood: 'cheese', hasTail: true }\n```\n\nGreat! The prototype of `ralph` has the same properties as the result because they _are_ the same object. `Object.getPrototypeOf()` is great for retrieving _the_ prototype of a given object.\n\n### The `constructor` Property\n\nEach time an object is created, a special property is assigned to it under the hood: `constructor`. Accessing an object's `constructor` property returns a reference to the constructor function that created that object in the first place! Here's a simple `Longboard` constructor function. We'll also go ahead and make a new object, then save it to a `board` variable:\n\n```js\nfunction Longboard() {\n  this.material = 'bamboo';\n}\n\nconst board = new Longboard();\n```\n\nIf we access `board`'s `constructor` property, we should see the original constructor function itself:\n\n```js\nconsole.log(board.constructor);\n\n// function Longboard() {\n//   this.material = 'bamboo';\n// }\n```\n\nExcellent! Keep in mind that if an object was created using literal notation, its constructor is the built-in `Object()` constructor function!\n\n```js\nconst rodent = {\n  favoriteFood: 'cheese',\n  hasTail: true\n};\n\nconsole.log(rodent.constructor);\n// function Object() { [native code] }\n```\n",
              "instructor_notes": ""
            },
            {
              "id": 469318,
              "key": "e6161624-c39d-4add-b6f5-ae8e9a42838e",
              "title": "",
              "semantic_type": "CheckboxQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "e6161624-c39d-4add-b6f5-ae8e9a42838e",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is true about `hasOwnProperty()`? Select all that apply:",
                "answers": [
                  {
                    "id": "a1512528837826",
                    "text": "An object is passed into `hasOwnProperty` as an argument",
                    "is_correct": false
                  },
                  {
                    "id": "a1512528851409",
                    "text": "It returns a boolean indicating whether the object has the specified property as its own property (i.e., the property isn't inherited)",
                    "is_correct": true
                  },
                  {
                    "id": "a1512528851896",
                    "text": "A string cannot be passed as an argument into `hasOwnProperty()`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512528852432",
                    "text": "`hasOwnProperty()` is invoked as a method onto an object",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 469319,
              "key": "67f57b74-9f19-4594-9f0b-0e10e93d4102",
              "title": "",
              "semantic_type": "CheckboxQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "67f57b74-9f19-4594-9f0b-0e10e93d4102",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is true about `isPrototypeOf()` or `getPrototypeOf()`? Select all that apply:",
                "answers": [
                  {
                    "id": "a1512528901042",
                    "text": "`isPrototypeOf()` checks whether or not an object exists in another object's prototype chain",
                    "is_correct": true
                  },
                  {
                    "id": "a1512528908528",
                    "text": "`isPrototypeOf()` takes a single argument: an object whose prototype chain is to be searched",
                    "is_correct": true
                  },
                  {
                    "id": "a1512528909040",
                    "text": "`getPrototypeOf()` is invoked on an instance of a constructor function (i.e., a single object itself)",
                    "is_correct": false
                  },
                  {
                    "id": "a1512528909592",
                    "text": "`getPrototypeOf()` returns the prototype of the object passed into it",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 469320,
              "key": "a3bf707e-1658-4358-ada6-ac75db22e384",
              "title": "",
              "semantic_type": "CheckboxQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "a3bf707e-1658-4358-ada6-ac75db22e384",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is true about `constructor` property? Select all that apply:",
                "answers": [
                  {
                    "id": "a1512528947868",
                    "text": "Accessing an object's `constructor` property returns a reference to the constructor function that created that object (instance)",
                    "is_correct": true
                  },
                  {
                    "id": "a1512528964441",
                    "text": "The value of the `constructor` property is just a string of the constructor function's name, rather than the function itself",
                    "is_correct": false
                  },
                  {
                    "id": "a1512528973936",
                    "text": "Every object has a `constructor` property",
                    "is_correct": true
                  },
                  {
                    "id": "a1512528974544",
                    "text": "Objects created with literal notation are constructed with the `Object()` constructor function",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 469321,
              "key": "943a3a10-82ac-4fbc-82a0-1bab356c7c71",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "943a3a10-82ac-4fbc-82a0-1bab356c7c71",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Let's say that we create the following object, `capitals`, using regular object literal notation:\n\n```js\nconst capitals = {\n  California: 'Sacramento',\n  Washington: 'Olympia',\n  Oregon: 'Salem',\n  Texas: 'Austin'\n};\n```\n\nWhat is returned when `Object.getPrototypeOf(capitals);` is executed?\n",
                "answers": [
                  {
                    "id": "a1512529013811",
                    "text": "A reference to `Object()`'s prototype",
                    "is_correct": true
                  },
                  {
                    "id": "a1512529024632",
                    "text": "`undefined`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512529025096",
                    "text": "`Object()`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512529025640",
                    "text": "`{}`",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 469322,
              "key": "c41e7174-c27f-41e3-97a9-be571f82c58f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Summary\n\nInheritance in JavaScript is when an object is based on _another_ object. Inheritance allows us to reuse existing code, having objects take on properties of other objects.\n\nWhen a function is called as a constructor using the `new` operator, the function creates and returns a new object. This object is secretly linked to its constructor's `prototype`, which is just another object. Using this secret link allows an object to access the `prototype`'s properties and methods as if it were its own. If JavaScript does not find a particular property within an object, it will keep looking up the prototype chain, eventually reaching `Object()` (top-level parent) if necessary.\n\nWe also looked at a few methods and properties that allow use to check the origins and references of objects and their prototypes, namely:\n\n* `hasOwnProperty()`\n* `isPrototypeOf()`\n* `Object.getPrototypeOf()`\n* `.constructor`\n\nIn the next section, we'll check out another part of prototypal inheritance in the form of **subclassing**. What if you want to inherit just a few properties from an object -- but want an object to also have other, specialized properties of their own? We'll take an even deeper dive into prototypal inheritance in the next section!\n",
              "instructor_notes": ""
            },
            {
              "id": 469323,
              "key": "0ddb9224-6b18-4be6-9b0f-b82e5076f92a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Further Research\n\n* [Object Playground](http://www.objectplayground.com/)\n* [hasOwnProperty()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty) on MDN\n* [isPrototypeOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf) on MDN\n* [Object.getPrototypeOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf) on MDN\n* [.constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor) on MDN",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 469324,
          "key": "ec211dfb-a817-4ff0-ae85-9fec23e3253f",
          "title": "Prototypal Inheritance: Subclasses",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "ec211dfb-a817-4ff0-ae85-9fec23e3253f",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 469325,
              "key": "c130dfe3-f87d-42c3-be6b-1ef29c703706",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Subclasses\n\nOne of the benefits of implementing inheritance is that it allows you to _reuse existing code_. By establishing inheritance, we can **subclass**, that is, have a \"child\" object take on most or all of a \"parent\" object's properties while retaining unique properties of its own.\n\nLet's say we have a parent `Animal` object, which contains properties like `age` and `weight`. That same `Animal` object can also access methods like `eat` and `sleep`.\n\nNow, let's also say that we want to create a `Cat` child object. Just like you can with other animals, you can also describe a cat by its _age_ or _weight_, and you can also be certain that the cat _eats_ and _sleeps_ as well. When creating that `Cat` object, then, we can simply re-write and re-implement all those methods and properties from `Animal` -- or, we can save some time and prevent repeated code by having `Cat` _inherit_ those existing properties and methods from `Animal`!\n\nNot only can `Cat` take on properties and methods of `Animal`, we can also give `Cat` its own unique properties and methods as well! Perhaps a `Cat` has a unique `lives` property of `9`, or it has a specialized `meow()` method that no `Animal` has. \n\nBy using prototypal inheritance, `Cat` only needs to implement `Cat`-specific functionality, and just reuse `Animal`'s existing functionality.\n",
              "instructor_notes": ""
            },
            {
              "id": 469326,
              "key": "73e21320-0969-455f-aae5-bfc81ae324a2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Inheritance Via Prototypes\n\nRecall the prototype chain from the previous section:\n",
              "instructor_notes": ""
            },
            {
              "id": 478574,
              "key": "120a1c0c-72c7-4561-869f-e8a07c62f443",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/December/5a31c70c_l3-83-prototype-chain-diagram/l3-83-prototype-chain-diagram.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/120a1c0c-72c7-4561-869f-e8a07c62f443",
              "caption": "_The `Cat()` constructor function is invoked using the `new` operator, which creates the `bailey` instance (object). Note that the `meow()` method is defined in the prototype of the `bailey` object's constructor function. The prototype is just an object, and all objects created by that constructor are secretly linked to the prototype. As such, we can execute `bailey.meow()` as if it were `bailey`'s own method!_",
              "alt": "",
              "width": 942,
              "height": 233,
              "instructor_notes": null
            },
            {
              "id": 469330,
              "key": "5f9338f6-1f92-4384-aca7-8ee6d38771b7",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "When calling any property on any object, the JavaScript engine will first look for the property in the object itself (i.e., the object's _own_, non-inherited properties). If the property is not found, JavaScript will then look at the object's prototype. If the property _still_ isn't found in the object's prototype, JavaScript will continue the search up the **prototype chain**.\n\nAgain, inheritance in JavaScript is all about setting up this chain!\n",
              "instructor_notes": ""
            },
            {
              "id": 469331,
              "key": "e5673138-f5d7-4899-b786-0c4c3ec2cb34",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## The Secret Link\n\nAs you know, an object's constructor function's prototype is first place searched when the JavaScript engine tries to access a property that doesn't exist in the object itself. Consider the following `bear` object with two properties, `claws` and `diet`:\n\n```js\nconst bear = {\n  claws: true,\n  diet: 'carnivore'\n};\n```\n\nWe'll assign the following `PolarBear()` constructor function's `prototype` property to `bear`:\n\n```js\nfunction PolarBear() { \n  // ...\n}\n\nPolarBear.prototype = bear;\n```\n\nLet's now call the `PolarBear()` constructor to create a new object, then give it two properties:\n\n```js\nconst snowball = new PolarBear();\n\nsnowball.color = 'white';\nsnowball.favoriteDrink = 'cola';\n```\n\nThis is how the `snowball` object looks at this point:\n\n```js\n{\n  color: 'white',\n  favoriteDrink: 'cola'\n}\n```\n\nNote that `snowball` has just two properties of its own: `color` and `favoriteDrink`. However, `snowball` _also_ has access to properties that _don't_ exist inside it: `claws` and `diet`:\n\n```js\nconsole.log(snowball.claws);\n// true\n\nconsole.log(snowball.diet);\n// 'carnivore'\n```\n\nSince `claws` and `diet` both exist as properties in the `prototype` object, they are looked up because objects are _secretly linked_ to their constructor's `prototype` property.\n\nGreat! But you may be wondering: just _what_ is this secret link that leads to the `prototype` object? Right after objects are made from the `PolarBear()` constructor (such as `snowball`), they have immediate access to properties in `PolarBear()`'s prototype. How exactly is this possible?\n\nAs it turns out, the secret link is `snowball`'s `__proto__` property (note the two underscores on each end). `__proto__` is a property of all objects (i.e., instances) made by a constructor function, and points directly to that constructor's `prototype` object. Let's check out what it looks like!\n\n```js\nconsole.log(snowball.__proto__);\n\n// { claws: true, diet: 'carnivore' }\n```\n\nSince the `__proto__` property refers to the same object as `PolarBear`'s prototype, `bear`, comparing them returns `true`:\n\n```js\nconsole.log(snowball.__proto__ === bear);\n\n// true\n```\n\n**It is highly discouraged to reassign the `__proto__` property, or even use it in any code you write**. First, there are compatibility issues across browsers. What's more: since the JavaScript engine searches and accesses properties along the prototype chain, mutating an object's prototype can lead to performance issues. The MDN article for  [__proto__](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto) even warns against using this property in red text at the very top of the page!\n\nIt's great to _know_ the secret link for learning how functions and objects are interconnected, but you **should not use `__proto__` to manage inheritance**. If you ever just need to review an object's prototype, you can still use `Object.getPrototypeOf()`.\n",
              "instructor_notes": ""
            },
            {
              "id": 469332,
              "key": "0b387742-c4b5-498a-af01-955f05981227",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "> ## 💡 What About Just Inheriting the Prototype? 💡\n>\n> Let's say we want a `Child` object to inherit from a `Parent` object. Why shouldn't we just set `Child.prototype = Parent.prototype`?\n>\n> First, recall that objects are passed by _reference_. This means that since the `Child.prototype` object and the `Parent.prototype` object refer to the _same object_ -- any changes you make to `Child`'s prototype will _also_ be made to `Parent`'s prototype! We don't want children being able to modify properties of their parents!\n>\n> On top of all this, no prototype chain will be set up. What if we want an object to inherit from any object we want, not just its prototype?\n>\n> We still need a way to efficiently manage inheritance without mutating the prototype at all. \n",
              "instructor_notes": ""
            },
            {
              "id": 469333,
              "key": "4c49c99d-5cb3-41ef-96bf-612383035021",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "4c49c99d-5cb3-41ef-96bf-612383035021",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Consider the following:\n\n```js\nfunction GuineaPig (name) {\n  this.name = name;\n  this.isCute = true;\n}\n\nconst waffle = new GuineaPig('Waffle');\n```\n\nWhat does `waffle.__proto__` refer to?",
                "answers": [
                  {
                    "id": "a1512540264501",
                    "text": "`GuineaPig.__proto__`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512540270586",
                    "text": "`GuineaPig.proto`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512540271059",
                    "text": "`GuineaPig.prototype`",
                    "is_correct": true
                  },
                  {
                    "id": "a1512540271549",
                    "text": "`guineapig.proto`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512540279160",
                    "text": "`GuineaPig`",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 469334,
              "key": "a6f54d4a-d9f8-4ba7-9e91-352910299164",
              "title": "",
              "semantic_type": "MatchingQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "a6f54d4a-d9f8-4ba7-9e91-352910299164",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "complex_prompt": {
                  "text": "Consider the following:\n\n```js\nfunction Car (color, year) {\n  this.color = color;\n  this.year = year;\n}\n\nCar.prototype.drive = function () {\n  console.log('Vroom vroom!');\n};\n\nconst car = new Car('silver', 1988);\n```\n\nWhat happens when `car.drive();` is executed? List the following events in the order that they occur:"
                },
                "concepts_label": "Order",
                "answers_label": "Event",
                "concepts": [
                  {
                    "text": "1st",
                    "correct_answer": {
                      "id": "a1512540324805",
                      "text": "First, the JavaScript engine searches inside the `car` object for a property named `drive`."
                    }
                  },
                  {
                    "text": "2nd",
                    "correct_answer": {
                      "id": "a1512540420574",
                      "text": "The JavaScript engine does not find `drive` within the `car` object."
                    }
                  },
                  {
                    "text": "3rd",
                    "correct_answer": {
                      "id": "a1512540421104",
                      "text": "The JavaScript engine then accesses the `car.__proto__` property."
                    }
                  },
                  {
                    "text": "4th",
                    "correct_answer": {
                      "id": "a1512540421754",
                      "text": "Since the `car.__proto__` property points to `Car.prototype`, the JavaScript engine searches for `drive` in the prototype."
                    }
                  },
                  {
                    "text": "5th",
                    "correct_answer": {
                      "id": "a1512540422284",
                      "text": "Because `Car.prototype.drive` _is_ a defined property, it is returned."
                    }
                  },
                  {
                    "text": "6th",
                    "correct_answer": {
                      "id": "a1512540427843",
                      "text": "Finally, since `drive` is invoked as a method on `car`, the value of `this` is set to `car`."
                    }
                  }
                ],
                "answers": [
                  {
                    "id": "a1512540324805",
                    "text": "First, the JavaScript engine searches inside the `car` object for a property named `drive`."
                  },
                  {
                    "id": "a1512540427843",
                    "text": "Finally, since `drive` is invoked as a method on `car`, the value of `this` is set to `car`."
                  },
                  {
                    "id": "a1512540420574",
                    "text": "The JavaScript engine does not find `drive` within the `car` object."
                  },
                  {
                    "id": "a1512540421104",
                    "text": "The JavaScript engine then accesses the `car.__proto__` property."
                  },
                  {
                    "id": "a1512540422284",
                    "text": "Because `Car.prototype.drive` _is_ a defined property, it is returned."
                  },
                  {
                    "id": "a1512540421754",
                    "text": "Since the `car.__proto__` property points to `Car.prototype`, the JavaScript engine searches for `drive` in the prototype."
                  }
                ]
              }
            },
            {
              "id": 469335,
              "key": "bfaf0d40-eae8-49c1-810b-5569d23ba2b1",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Object.create()\n\nAt this point, we've reached a few roadblocks when it comes to inheritance. First, even though  `__proto__` can access the prototype of the object it is called on, using it in any code you write is not good practice. \n\nWhat's more: we also shouldn't inherit _only_ the prototype; this doesn't set up the prototype chain, and any changes that we made to a child object will also be reflected in a parent object. \n\nSo how should we move forward?\n\nThere's actually a way for us to set up the prototype of an object ourselves: using `Object.create()`. And best of all, this approach lets us manage inheritance _without_ altering the prototype!\n\n`Object.create()` takes in a single object as an argument, and returns a new object with its `__proto__` property set to what argument is passed into it. From that point, you simply set the returned object to be the prototype of the child object's constructor function. Let's check out an example!\n\nFirst, let's say we have a `mammal` object with two properties: `vertebrate` and `earBones`:\n\n```js\nconst mammal = {\n  vertebrate: true,\n  earBones: 3\n};\n```\n\nRecall that `Object.create()` takes in a single object as an argument, and returns a _new_ object. That new object's `__proto__` property is set to whatever was originally passed into `Object.create()`. Let's save that returned value to a variable, `rabbit`:\n\n```js\nconst rabbit = Object.create(mammal);\n```\n\nWe expect the new `rabbit` object to be blank, with no properties of its own:\n\n```js\nconsole.log(rabbit);\n\n// {}\n```\n\nHowever, `rabbit` should now be secretly linked to `mammal`. That is, its `__proto__` property should point to `mammal`:\n\n```js\nconsole.log(rabbit.__proto__ === mammal);\n\n// true\n```\n\nGreat! This means that now, `rabbit` extends `mammal` (i.e., `rabbit` inherits from `mammal`). As a result, `rabbit` can access `mammal`'s properties as if it were its own!\n\n```js\nconsole.log(rabbit.vertebrate);\n// true\n\nconsole.log(rabbit.earBones);\n// 3\n```\n\n`Object.create()` gives us a clean method of establishing prototypal inheritance in JavaScript. We can easily extend the prototype chain this way, and we can have objects inherit from just about any object we want! \n\nLet's check out a more involved example below:\n",
              "instructor_notes": ""
            },
            {
              "id": 478410,
              "key": "59bcd667-b085-4743-9c5c-3ba42a1e5cab",
              "title": "L3 - 88 - Object.Create Demo",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "K7CKb7MlAT4",
                "china_cdn_id": "K7CKb7MlAT4.mp4"
              }
            },
            {
              "id": 492754,
              "key": "e30aeeb1-cac2-4ccf-9a45-da42d13ea2c2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "[Here's the code from the preceding video.](https://github.com/udacity/OOJS-screencasts/blob/master/L3-objects-and-classes/90-objectcreate-demo.js)",
              "instructor_notes": ""
            },
            {
              "id": 469338,
              "key": "03df26a7-75a9-406a-9991-0497047133b0",
              "title": "",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "03df26a7-75a9-406a-9991-0497047133b0",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Consider the following:\n\n```js\nfunction Parent() {\n  // ...\n}\n\nfunction Child() {\n  // ...\n}\n\nChild.prototype = Object.create(Parent.prototype);\n\nconst child = new Child();\n```\n\nThe following is then executed:\n\n```js\nchild instanceof Parent;\n```\n\nWhat is printed to the console?\n",
                "answers": [
                  {
                    "id": "a1512540525318",
                    "text": "`Child`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512540543369",
                    "text": "`undefined`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512540543792",
                    "text": "`false`",
                    "is_correct": false
                  },
                  {
                    "id": "a1512540544153",
                    "text": "`true`",
                    "is_correct": true
                  },
                  {
                    "id": "a1512540544786",
                    "text": "The console will throw an error.",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 469339,
              "key": "7af9894b-0f0e-46ee-9372-b00e2a8e5a06",
              "title": "",
              "semantic_type": "CheckboxQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "7af9894b-0f0e-46ee-9372-b00e2a8e5a06",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "What is true about `Object.create()`? Select all that apply:",
                "answers": [
                  {
                    "id": "a1512540625400",
                    "text": "It returns a new object whose `__proto__` property is set to the object passed into `Object.create()`",
                    "is_correct": true
                  },
                  {
                    "id": "a1512540636015",
                    "text": "Using `Object.create()`, we can have objects inherit from just about any object we want (i.e., not only the `prototype`)",
                    "is_correct": true
                  },
                  {
                    "id": "a1512540636489",
                    "text": "`Object.create()` allows us to implement prototypal inheritance without mutating the prototype",
                    "is_correct": true
                  },
                  {
                    "id": "a1512540637025",
                    "text": "The method is invoked directly _on_ a single object",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 469340,
              "key": "fc9d7ba7-a5b9-4498-91f7-d9d2b00ad477",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Summary\n\nInheritance in JavaScript is all about setting up the prototype chain. This allows us to **subclass**, that is, create a \"child\" object that inherits most or all of a \"parent\" object's properties and methods. We can then implement any of the child object's unique properties and methods separately, while still retaining data and functionality from its parent.\n\nAn object (instance) is secretly linked to its constructor function's prototype object through that instance's `__proto__` property. **You should never use the `__proto__` property in any code you write.** Using `__proto__` in any code, or even inheriting just the prototype directly, leads to some unwanted side effects. \n\nTo efficiently manage inheritance in JavaScript, an effective approach is to avoid mutating the prototype completely. `Object.create()` allows us to do just that, taking in a parent object and returning a _new_ object with its `__proto__` property set to that parent object.\n",
              "instructor_notes": ""
            },
            {
              "id": 469341,
              "key": "1f3e2f1d-cbd6-4b1e-86f2-87bd790f3330",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Further Research\n\n* [Inheritance and the prototype chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain) on MDN\n* [Object.create()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create) on MDN",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 469342,
          "key": "7b03542a-fb93-40ca-b903-03e44d95381e",
          "title": "Lesson Summary",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "7b03542a-fb93-40ca-b903-03e44d95381e",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 478411,
              "key": "e136b692-a0c5-45bc-ac2f-b8c479f69df8",
              "title": "Classes and Objects - Summary",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "zSg4K0DoAEc",
                "china_cdn_id": "zSg4K0DoAEc.mp4"
              }
            }
          ]
        },
        {
          "id": 469344,
          "key": "05f7161c-420a-47e8-be6f-ba227eac0dd5",
          "title": "Course Outro",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "05f7161c-420a-47e8-be6f-ba227eac0dd5",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 478412,
              "key": "730b2c3c-3f88-4064-823a-bccd6779536f",
              "title": "Course Outro",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "60zCDUSyjpI",
                "china_cdn_id": "60zCDUSyjpI.mp4"
              }
            }
          ]
        }
      ]
    }
  },
  "_deprecated": [
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    }
  ]
}